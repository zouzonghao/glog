# 指南：将 Go Web 项目的静态资源打包进单一可执行文件

本文档总结了将一个典型的 Go Web 项目（以 Glog 为例）的所有静态资源（模板、CSS、JS、图片等）嵌入到最终的可执行文件中的完整过程。这样做可以实现真正的单一文件部署，极大简化了分发和运维的复杂度。

我们使用了 Go 1.16+ 内置的 `embed` 包，并通过**构建标签 (Build Tags)** 实现了开发模式与生产模式的无缝切换，提供了最佳的开发与部署体验。

---

## 第一步：调整项目结构以适应 `embed`

`go:embed` 指令有一个重要的限制：**它不允许在路径中使用 `..` 来引用父目录**。

为了解决这个问题，我们将程序入口 `main.go` 移动到了项目根目录，这是最符合 `embed` 设计思想的方案。

**最终结构**:
```
/
├── main.go          <-- 主程序逻辑
├── assets_dev.go    <-- 开发模式资源加载器
├── assets_prod.go   <-- 生产模式资源加载器
├── build.go         <-- 构建时资源处理脚本
├── Makefile         <-- 自动化构建流程
├── templates/
├── static/
└── internal/utils/dict/ <-- gojieba 字典文件
└── ...
```

---

## 第二步：使用构建标签分离开发与生产逻辑

为了避免在生产环境运行时依赖环境变量，我们采用构建标签来编译不同版本的代码。

### 开发模式 (`assets_dev.go`)
这个文件在默认情况下被编译，它从文件系统实时加载资源，方便开发。

```go
//go:build !release

package main
// ...
```

### 生产模式 (`assets_prod.go`)
这个文件仅在编译时提供了 `-tags release` 标志后才会被编译，它将资源嵌入到二进制文件中。

```go
//go:build release

package main
// ...
```

---

## 第三步：实现发布时资源自动化压缩

为了进一步优化生产环境的性能并减小最终可执行文件的体积，我们实现了一个自动化的资源压缩流程。该流程会在 `release` 构建之前自动执行。

### 核心思路
- **纯 Go 实现**：我们选择了 `github.com/tdewolff/minify/v2` 这个强大的 Go 库，以避免引入 Node.js、npm 等外部依赖，保持了 Go 项目的纯粹性。
- **构建时处理**：所有压缩和文件修改操作都在编译之前进行，确保嵌入到二进制文件中的是优化后的资源。
- **自动化与清理**：整个流程通过 `Makefile` 实现一键化，并在构建完成后自动清理临时文件，保持开发目录的整洁。

### 实现细节

1.  **`build.go` 脚本**: 一个独立的构建工具，负责压缩 CSS/JS、更新 HTML 引用，并能在构建后进行清理。
2.  **`Makefile`**: 采用“先编译工具，后执行工具”的稳健策略，编排整个发布流程。

---

## 第四步：解决 CGO 交叉编译与运行时依赖难题（经验总结）

当项目依赖 CGO（例如 `gojieba` 分词库）时，会遇到编译和运行时的双重挑战。

### 问题 1：交叉编译失败
- **现象**: 在 macOS 上为 Linux 交叉编译时，构建失败。
- **根源**: CGO 交叉编译需要一个目标平台的 C/C++ 交叉编译工具链。
- **解决方案**: 安装 `Zig` (`brew install zig`)，并配置 `Makefile` 在交叉编译时自动使用 `Zig` 作为 C/C++ 编译器。`Makefile` 会处理 Go 平台变量到 `Zig` 目标三元组的转换。

### 问题 2：运行时字典文件缺失 (`panic: Dictionary file does not exist`)
- **现象**: 交叉编译成功后，在目标服务器上运行程序时立即崩溃，提示找不到字典文件。
- **根源**: `gojieba` 在启动时需要加载字典文件，而这些文件只存在于开发环境中，并未被打包进二进制文件。
- **最终解决方案**: 我们将 `gojieba` 的字典文件复制到项目源码的 `internal/utils/dict/` 目录下，并使用 Go 的 `embed` 功能将它们嵌入到最终的二进制文件中。接着，我们修改了 `internal/utils/segmenter.go`，让它在程序启动时，将嵌入的字典文件写入一个临时目录，然后将这些临时文件的路径传递给 `gojieba` 进行初始化。这确保了程序无论在哪里运行，都能找到所需的字典，实现了真正的单一文件部署。

---

## 最终的开发与部署流程

这个方案提供了最优的开发和部署体验。

### 开发
直接使用 `go run .` 或 `make run`。

```bash
make run
```

### 部署
编译生产版本时，只需执行 `make release`。

#### 编译当前系统版本
```bash
make release
```

#### 交叉编译 (支持 CGO)
通过在 `make` 命令中传递 `TARGET_GOOS` 和 `TARGET_GOARCH` 变量，可以轻松地为其他平台编译。
```bash
# 编译 Linux (amd64) 版本
make release TARGET_GOOS=linux TARGET_GOARCH=amd64

# 编译 Windows (amd64) 版本
make release TARGET_GOOS=windows TARGET_GOARCH=amd64
```
所有编译出的文件都是完全独立的，可以直接部署运行。
```bash
# 在 Linux 上运行
./glog-linux-amd64