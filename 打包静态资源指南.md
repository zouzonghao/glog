# 指南：将 Go Web 项目的静态资源打包进单一可执行文件

本文档总结了将一个典型的 Go Web 项目（以 Glog 为例）的所有静态资源（模板、CSS、JS、图片等）嵌入到最终的可执行文件中的完整过程。这样做可以实现真正的单一文件部署，极大简化了分发和运维的复杂度。

我们使用了 Go 1.16+ 内置的 `embed` 包，并通过**构建标签 (Build Tags)** 实现了开发模式与生产模式的无缝切换，提供了最佳的开发与部署体验。

---

## 第一步：调整项目结构以适应 `embed`

`go:embed` 指令有一个重要的限制：**它不允许在路径中使用 `..` 来引用父目录**。

为了解决这个问题，我们将程序入口 `main.go` 移动到了项目根目录，这是最符合 `embed` 设计思想的方案。

**最终结构**:
```
/
├── main.go          <-- 主程序逻辑
├── assets_dev.go    <-- 开发模式资源加载器
├── assets_prod.go   <-- 生产模式资源加载器
├── build.go         <-- 构建时资源处理脚本
├── Makefile         <-- 自动化构建流程
├── templates/
├── static/
└── internal/utils/dict/ <-- 分词库词典文件
└── ...
```

---

## 第二步：使用构建标签分离开发与生产逻辑

为了避免在生产环境运行时依赖环境变量，我们采用构建标签来编译不同版本的代码。

### 开发模式 (`assets_dev.go`)
这个文件在默认情况下被编译，它从文件系统实时加载资源，方便开发。

```go
//go:build !release

package main
// ...
```

### 生产模式 (`assets_prod.go`)
这个文件仅在编译时提供了 `-tags release` 标志后才会被编译，它将资源嵌入到二进制文件中。

```go
//go:build release

package main
// ...
```

---

## 第三步：实现发布时资源自动化压缩

为了进一步优化生产环境的性能并减小最终可执行文件的体积，我们实现了一个自动化的资源压缩流程。该流程会在 `release` 构建之前自动执行。

### 核心思路
- **纯 Go 实现**：我们选择了 `github.com/tdewolff/minify/v2` 这个强大的 Go 库，以避免引入 Node.js、npm 等外部依赖，保持了 Go 项目的纯粹性。
- **构建时处理**：所有压缩和文件修改操作都在编译之前进行，确保嵌入到二进制文件中的是优化后的资源。
- **自动化与清理**：整个流程通过 `Makefile` 实现一键化，并在构建完成后自动清理临时文件，保持开发目录的整洁。

### 实现细节

1.  **`build.go` 脚本**: 一个独立的构建工具，负责压缩 CSS/JS、更新 HTML 引用，并能在构建后进行清理。
2.  **`Makefile`**: 采用“先编译工具，后执行工具”的稳健策略，编排整个发布流程。

---

## 第四步：解决 CGO 依赖与二进制体积问题（经验总结）

当项目依赖 CGO（例如早前使用的 `gojieba` 分词库）时，会遇到编译复杂和最终可执行文件体积膨胀的问题。

### 问题 1：CGO 交叉编译失败
- **现象**: 在 macOS 上为 Linux 交叉编译时，构建失败。
- **根源**: CGO 交叉编译需要一个目标平台的 C/C++ 交叉编译工具链。
- **历史解决方案**: 安装 `Zig` (`brew install zig`)，并配置 `Makefile` 在交叉编译时自动使用 `Zig` 作为 C/C++ 编译器。

### 问题 2：二进制文件体积膨胀
- **现象**: 引入 CGO 依赖后，可执行文件体积从 27MB 激增到 54MB。
- **根源**: `gojieba` 底层依赖 C++ 库，导致约 16MB 的 C++ 静态库和运行时被打包进最终文件。此外，约 11MB 的词典文件也被 `embed` 嵌入。
- **最终解决方案**: 我们将 `gojieba` 替换为纯 Go 实现的 `gse` 分词库。这从根本上移除了 CGO 依赖，使得交叉编译不再需要 `Zig` 等额外工具，同时也彻底解决了二进制文件体积膨胀的问题。词典文件现在从外部加载，不再嵌入到程序中，进一步减小了体积并提高了灵活性。

---

## 最终的开发与部署流程

这个方案提供了最优的开发和部署体验。

### 开发
直接使用 `go run .` 或 `make run`。

```bash
make run
```

### 部署
编译生产版本时，只需执行 `make release`。

#### 编译当前系统版本
```bash
make release
```

#### 交叉编译
由于已经移除了 CGO 依赖，现在交叉编译变得极其简单，不再需要 `Zig`。
```bash
# 编译 Linux (amd64) 版本
GOOS=linux GOARCH=amd64 make release

# 编译 Windows (amd64) 版本
GOOS=windows GOARCH=amd64 make release
```
所有编译出的文件都是完全独立的，可以直接部署运行。
```bash
# 在 Linux 上运行
./glog-linux-amd64